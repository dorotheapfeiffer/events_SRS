// tu run this macro type:
// root 
#include <string.h>
#include <stdio.h>
#include <string.h>
#include "TFile.h"
#include "TMath.h"

typedef struct {
   UInt_t	n_words	   : 12;
   UInt_t	adc_res	   : 3;
   UInt_t	out_format : 1;
   UInt_t	module_id  : 8;	
   UInt_t	sub_header : 6;
   UInt_t	header_sig : 2;
} EventHeader;

typedef struct {
   UInt_t	adc_data   : 14;
   UInt_t	overflow   : 1;
   UInt_t	nop        : 1;
   UInt_t	channel	   : 5;	
   UInt_t	fix	   : 9;
   UInt_t	data_sig   : 2;
} DataWord;

typedef struct {
   UInt_t	counter_tts: 30;
   UInt_t	end_event  : 2;
} EndOfEvent;

static union {
   UInt_t	m_Header;
   EventHeader  m_EventHeader;
};

static union {
   UInt_t	m_Word;
   DataWord	m_DataWord;
};

static union {
   UInt_t	m_Footer;
   EndOfEvent	m_EndOfEvent;
};



Int_t value2Pos(float *table, Int_t value){
  
   //Long64_t a = TMath::BinarySearch((Long64_t)65, (const float*)tab, (Int_t)value); 
  
   for(Int_t i = 0; i < 65; i++){
       if( value < table[i] )
         return i;
      }

return -1;
}

//=====================================================================================================
Int_t adc2pos(Int_t bin){
// pos = 22mV/bin + 460(fixed_offset_adc) + 355*address;
// values 0.46 - 3.3 V

    Int_t fixed_offset_adc = 400;
    Int_t address = 0;
    
    //printf("bimf:%d \t posf: %d \t |", bin, (( Double_t(bin) - 400. ) / 22. )+0.5); 
    return ((bin - fixed_offset_adc -  355*address ) / 22) + 0.5;
}

//=====================================================================================================
 /*
    if(value < tab[0]) return pos;
    else if(value > tab[size-1]) return size;
    else return pos = size * (int)(value - tab[0]) / (tab[size-1] - tab[0]);  
*/


//=====================================================================================================


void readBin(string filename) {

//====================================================================================================
   const Int_t size = 65;
   float tabx[ size ] = { 535.,  545.,  565.,  585.,  605.,  625.,  645.,  665.,  685.,  711.,  733.,  753.,  775.,  797.,  816.,  838.,  
                          866.,  884.,  905.,  923.,  944.,  967.,  989., 1011., 1032., 1054., 1072., 1095., 1118., 1140., 1162., 1182., 
                         1204., 1229., 1247., 1268., 1289., 1307., 1328., 1350., 1373., 1393., 1412., 1434., 1456., 1480., 1500., 1520., 
                         1547., 1570., 1591., 1632., 1655., 1675., 1695., 1720., 1745., 1765., 1785., 1810., 1832., 1854., 1878., 1900., 
                         1921.};
   float taby[ size ];

   for (Int_t nri = 0; nri < 65; nri++){ 
       taby[nri] = 100.;  
       }

   //====================================================================
   //  part for Anton to convert data (remove unwanted, corrupted data)
   //
   /*
   std::ifstream is (filename, std::ifstream::binary);
   char *bufferW; 
   if (is) {
      // get length of file:
      is.seekg (0, is.end);
      int length = is.tellg();
      is.seekg (0, is.beg);
      bufferW = new char [length];
      is.close();
    }    

   UInt_t offset = 0;
   */
   //====================================================================



   TH1F* hPh1 = new TH1F("hPh1", "hPh1", 4000, 0, 4000);
   TH1F* hPh2 = new TH1F("hPh2", "hPh2", 4000, 0, 4000);
   TH1F* hPh3 = new TH1F("hPh3", "hPh3", 4000, 0, 4000);
   TH1F* hPh4 = new TH1F("hPh4", "hPh4", 4000, 0, 4000);
   TH1F* hPos1 = new TH1F("hPos1", "hPos1", 4000, 0, 4000);
   TH1F* hPos2 = new TH1F("hPos2", "hPos2", 4000, 0, 4000);
   TH1F* hPos3 = new TH1F("hPos3", "hPos3", 4000, 0, 4000);
   TH1F* hPos4 = new TH1F("hPos4", "hPos4", 4000, 0, 4000);

   TH1F* hTimeStamp = new TH1F("hTimeStamp", "hTimeStamp", 10000, 0, 300000);


 //  TGraph *gr       = new TGraph(65, tabx, taby); 

   Bool_t DEBUG = kFALSE;
   //DEBUG = kTRUE;
   Int_t wrong = 0;

   printf("%s\n", filename.c_str());
   FILE *f = fopen(Form("%s", filename.c_str()), "r");
   if (f == NULL) {
      printf("Cannot find file \'%s\'\n", filename.c_str());
      return;
      }

   UInt_t i = 0;
   while( fread(&m_Header, sizeof(m_Header), 1, f) > 0){
     if(DEBUG) printf("read data 0x%X in the data stream, wordnr: %d, header_sig: %d\n", m_Header, i, m_EventHeader.header_sig); 
     if(m_EventHeader.header_sig == 0x1){
        if(DEBUG){
           printf(" + Found data 0x%X in the data stream, nr %d\n", m_Header, i); 
           printf("	header_sig: %d\n", m_EventHeader.header_sig ); 
           printf("	sub_header: %d\n", m_EventHeader.sub_header ); 
           printf("	module_id : %d\n", m_EventHeader.module_id  ); 
           printf("	out_format: %d\n", m_EventHeader.out_format ); 
           printf("	adc_res	  : %d\n", m_EventHeader.adc_res    ); 
           printf("	n_words	  : %d\n", m_EventHeader.n_words    ); 
          }

        // Anton's part
        //memcpy(bufferW + offset, &m_Header, sizeof(m_Header));   
        //offset += sizeof(m_Header);
        // end A

        UInt_t m_value_adc[33];;
        Int_t pos1;
        for(Int_t n = 0; n < m_EventHeader.n_words-1; n++){
            fread(&m_Word, sizeof(m_Word), 1, f);

            // Anton's part
            //memcpy(bufferW + offset, &m_Word, sizeof(m_Word));   
            //offset += sizeof(m_Word);
            // end A

            m_value_adc[ m_DataWord.channel ] = m_DataWord.adc_data;

            if(DEBUG) printf("	dsig: %d, chn: %d, over: %d, adc: %d\n",m_DataWord.data_sig, m_DataWord.channel, 
                                                                        m_DataWord.overflow, m_DataWord.adc_data); 
           }
        fread(&m_Footer, sizeof(m_Footer), 1, f);
        m_value_adc[32 ] = m_EndOfEvent.counter_tts; 

        if(DEBUG) printf("    dsig: %d, tts: %u\n",m_EndOfEvent.end_event, m_EndOfEvent.counter_tts); 
        // Anton's part
        //   memcpy(bufferW + offset, &m_Footer, sizeof(m_Footer));   
        //   offset += sizeof(m_Footer);
        // end A

        hPh1->Fill(m_value_adc[0]);
        hPh2->Fill(m_value_adc[1]);
        hPh3->Fill(m_value_adc[2]);
        hPh4->Fill(m_value_adc[3]);
        hPos1->Fill(m_value_adc[4]);
        hPos2->Fill(m_value_adc[5]);
        hPos3->Fill(m_value_adc[6]);
        hPos4->Fill(m_value_adc[7]);
       
        hTimeStamp->Fill(m_value_adc[32]); 
       //timestamp->SetBinContent(i, m_EndOfEvent.counter_tts );
       }
       else{
         wrong++;
         cout << "something is wrong there is no header signal "<< wrong << endl;
       }
       //break;
  
     i++;  
    //if( !(i % 1000)) printf("read %d words\n", i);
    }

  printf("filename %s, read: %d words, wrong: %d\n", filename.c_str(), i, wrong);

  // for Anton 
  /*
   std::string fileConvert = filename + string("2");
   std::ofstream dataConvert(fileConvert, std::ofstream::out | std::ofstream::binary);
    if(!dataConvert.is_open()) {
       std::cout << "ERROR could not open the file... " << fileConvert << std::endl;
       }
    else {
       dataConvert.write(bufferW, offset);
       dataConvert.close();
       std::cout << "new file ["<<  fileConvert << "] is created"  << std::endl;
      }
    delete bufferW;
   */
  // for Anton
  

  TCanvas *c1 = new TCanvas("c1","c1",800, 600);
  c1->Divide(4,2,0,0);
  //...............
  c1->cd(1); hPh1->Draw();  gPad->SetLogy();
  c1->cd(2); hPh2->Draw();  gPad->SetLogy();
  c1->cd(3); hPh3->Draw();  gPad->SetLogy();
  c1->cd(4); hPh4->Draw();  gPad->SetLogy();
  //...............
  c1->cd(5); hPos1->Draw(); gPad->SetLogy();
  c1->cd(6); hPos2->Draw(); gPad->SetLogy();
  c1->cd(7); hPos3->Draw(); gPad->SetLogy();
  c1->cd(8); hPos4->Draw(); gPad->SetLogy();
  //...............
  
  TCanvas *c2 = new TCanvas("c2","c2",800, 600);
  c2->cd();
  hTimeStamp->Draw();
  
//////////////////////////////////////////////////////////////////
// pos = 22mV/bin + 460(fixed_offset_adc) + 355*address;
//////////////////////////////////////////////////////////////////
}
